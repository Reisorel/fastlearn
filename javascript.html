<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Site mémo JS !</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/tomorrow-night-blue.min.css">

</head>

<body>
  <header>
    <h1 class="header-title"><a href="#">Site mémo JS !</a></h1>
    <a class="btn-back-to-top">Chapitre aléatoire</a>
  </header>
  <nav>
    <ol>

      <li><a href="#typesdedonnees">Types de données</a></li>
      <li><a href="#variables">Variables et opérateurs</a></li>
      <li><a href="#boîtes">Boîtes</a></li>
      <li><a href="#fonctions">Fonctions</a></li>
      <li><a href="#logique">La logique</a></li>
      <li><a href="#boucles">Les boucles </a></li>
      <li><a href="#mémoire">Emplacements de mémoire</a></li>
      <li><a href="#tableaux">Tableaux</a></li>
      <li><a href="#objets">Objets JS</a></li>
      <li><a href="#BOM">BOM (Browser Oriented Model)</a></li>
      <li><a href="#DOM">BOM (Document Oriented Model)</a></li>
      <li><a href="#évènements">Evénements</a></li>
      <li><a href="#POO">POO</a></li>
      <li><a href="#date">Date</a></li>
      <li><a href="#API">API</a></li>
      <li><a href="#asynchrone">Asynchrone</a></li>
      <li><a href="#cookies">Cookies</a></li>
      <li><a href="#inclassables">Inclassables</a></li>
    </ol>
  </nav>

  <main>
    <section id="typesdedonnees">
      <h1>Types de données</h1>
      <div id="cours">
        <h1>Cours</h1>
        <h2>Primitives</h2>
        <pre style="tab-size: 2;">
          <code>
// Nombre :
42, 3.14
// Chaîne de caractères (String) :
"Hello, World!"
//Booléen :
true, false
// Null :
null
//Undefined :
undefined
//Symbol :
Symbol('foo')
//Big int :
const monBigInt = BigInt(12345678901234567890);
          </code>
        </pre>

        <h2>Objets</h2>
        <pre style="tab-size: 2;">
          <code>
// Objet
{ nom: "John", âge: 30 }
// Fonction
function additionner(a, b) { return a + b; }
//Date :
new Date()
//Expression régulière (RegExp) :
/[a-z]+/
//Erreur :
new Error('Une erreur est survenue')
          </code>
        </pre style="tab-size: 2;">
        <h2>Copie partielle / profonde</h2>
        <p>
          Duplication de données où seules les références aux emplacements de mémoire des objets sont copiées, plutôt
          que les objets eux-mêmes. Les nouvelles variables pointent vers les mêmes objets en mémoire
          que les variables originales, entraînant des modifications répercutées sur l'objet original en cas de
          modification de la copie partielle.
          </br>
          Cela ne s'applique pas aux types de données primitifs, car ils sont immuables, ce qui signifie que leur valeur
          ne peut pas être modifiée une fois qu'ils sont créés.
        </p>
        <pre>
          <code>
// Création de l'objet original
let personnageOriginal = {
    nom: "Ezio",
    niveau: 50,
    pointsDeVie: 100
};

// Copie partielle de l'objet
let copiePartielle = personnageOriginal;

// Modification de la copie
copiePartielle.pointsDeVie = 80;

// Affichage des valeurs originales
console.log("Valeurs originales :");
console.log(personnageOriginal);

// Affichage des valeurs de la copie
console.log("Valeurs de la copie après modification :");
console.log(copiePartielle);
          </code>
        </pre>
        <p>Aperçu de l'output du console.log</p>
        <pre>
          <code style="tab-size: 2;">
Valeurs originales :
{ nom: 'Ezio', niveau: 50, pointsDeVie: 80 }
Valeurs de la copie après modification :
{ nom: 'Ezio', niveau: 50, pointsDeVie: 80 }
          </code>
        </pre>
      </div>
      <div id="questions">
      </div>
    </section>

    <section id="variables">
      <h1>Les variables et les opérateurs</h1>
      <div id="cours">
        <h1>Cours </h1>
        <h2>Variables</h2>

        <h2>Déclarations de variables</h2>
        <p>let / const / var (obsolète)</p>
        <p>On peut redéclarer des variables var sans provoquer d'erreurs.</p>
        <p>On ne peut pas déclarer de const vide contrairement à let ou var.</p>
        <p>Les constantes doivent toujours être initialisées avec des valeurs</p>

        <h2>Concaténation</h2>
        <p>Joindre plusieurs chaînes de caractères ensemble pour former une seule chaîne avec l'opérateur "+"</p>

        <h2>Portée des variables</h2>
        <p>Let et const sont block-scoped (condition, switch, fonction, boucle for...)</p>

        <h2>Le Hoisting</h2>
        <p>toutes les variables se font hisser dans un objet "variable object"</p>
        <p>Une variable var se fait hoisted et peut être utilisée avant sa déclaration, car elle est initialisée à
          undefined.
          Let & const sont hoisted mais pas initialisées.</p>
        <p>Les déclarations de fonctions et de variables sont hissées en JavaScript. ELles sont stockées dans la mémoire
          du VO(Variables Object)
          du contexte d'exécution actuel et rendues disponibles dans le contexte d'exécution avant même que l'exécution
          du code ne commence.
          Seule la délcaration est hissée, pas sa valeur.
        <pre style="tab-size: 2;">
            <code>
  console.log(x); // undefined
  var x = 5;
  console.log(x); // 5
            </code>
          </pre>
        </p>
        <h2>Template littéral</h2>
        <pre style="tab-size: 2;">
          <code>
  console.log(`backticks et dollar pour ${variable} et ${fonctions()}`);
          </code>
        </pre>

        <h2>les Closures</h2>
        <ul>
          <li>
            Fonction interne qui a accès aux variables de son scope parent, même après que la fonction
            parent ait été exécutée et que son scope soit théoriquement "fermé".
          </li>
          <li>
            Cela permet à la fonction interne de conserver et d'utiliser les valeurs des variables externes même après
            la fin de l'exécution de la fonction parent.
          </li>
        </ul>
        <pre>
          <code>
function creerCompteur() {
  // Déclare une variable compteur et l'initialise à 0
  let compteur = 0;

  // Déclare une fonction interne incrementer
  function incrementer() {
      // Incrémente la variable compteur à chaque appel
      compteur++;
      // Affiche la valeur actuelle de compteur dans la console
      console.log(compteur);
  }

  // Renvoie la fonction incrementer
  return incrementer;
}
// Appelle creerCompteur et stocke la fonction retournée dans monCompteur
// IMPORTANT, c'est cette assignation qui crée la closure,
// Elle établit le lien entre l'environnement lexical de la fonction interne...
//...et son utilisation en dehors de ce contexte."

// Appelle la fonction stockée dans monCompteur (incrementer) plusieurs fois
monCompteur(); // Affiche 1
monCompteur(); // Affiche 2
monCompteur(); // Affiche 3
          </code>
        </pre>
      </div>

      <div id="questions">
        <h1>Questions </h1>
        <h2><a href="quiz_js.html">Lien quizz variables</a></h2>
      </div>
    </section>


    </section>
    <br>
    <section id="boîtes">
      <h1>Demander / afficher des infos aux utilisateurs</h1>
      <h2>Afficher info</h2>
      <h2>Demander info</h2>
      <h2>Demander confirmation</h2>
      <h2>Demander des renseignements</h2>
    </section>
    <br>
    <section id="fonctions">
      <h1>Les fonctions</h1>
      <h2>Qu'est-ce qu'une fonction</h2>
      <h2>Paramètres</h2>
      <p>
      <ul>
        <li>Paramètre : quand on crée la fonction</li>
        <li>Argument : quand on passe un élément dans le paramètre</li>
      </ul>
      </p>
      <h2>Types de fonctions</h2>
      <h3>fonctions classique</h3>
      <p>
      <ul>
        <li>Possèdent un "this", sorte de variable disponible dans le contexte de la fonction.</li>
      </ul>
      </p>
      <pre style="tab-size: 2;">
          <code>
  function standardFunction(x, y) {
    return x + y;
}
          </code>
        </pre>
      <h3>fonctions nommées</h3>
      <pre style="tab-size: 2;">
        <code>
  function namedFunction(x, y) {
    return x * y;
}
        </code>
      </pre>
      <h3>fonctions anonymes</h3>
      <pre style="tab-size: 2;">
        <code>
  let anonymousFunction = function() {
    console.log("Je suis une fonction anonyme !");
};
        </code>
      </pre>
      <h3>fonctions fléchées</h3>
      <p>
      <ul>
        <li>N'utilisant pas this autonome </li>
        <li>Peuvent lire le this d'une fonction classique si elles se
          situent dedans.</li>
        <li>Lisent le .this du contexte global de la fonction</li>
        <li>Elles utilisent l'opérateur => pour définir la fonction.</li>
      </ul>
      </p>
      <pre style="tab-size: 2;">
        <code>
// Définition d'une fonction fléchée pour multiplier deux nombres
const multiplier = (a, b) => a * b;

// Utilisation de la fonction fléchée pour calculer le produit de deux nombres
const resultat = multiplier(5, 3);
console.log("Le résultat est : " + resultat);
// Affiche : "Le résultat est : 15"
        </code>
      </pre>
      <h3>Fonctions pures</h3>
      <p>
      <ul>
        <li>Retournent toujours la même chose en fonction des mêmes arguments fournis.</li>
        <li>N'utilise aucune valeur mutable et n'a pas d'effets secondaires en dehors de son bloc.</li>
        <li>Le résultat ne doit pas changer par rapport à une variable externe</li>
      </ul>
      </p>
      <pre style="tab-size: 2;">
            <code>
function add(a,b) {
  return a + b
}
console.log(add(10,10))
//Ici la fonction add renvera toujours le même résultat.

const number = 99
function add(a,b) {
  number++
  return a + b
}
console.log(add(10,10))
// Ici on a un effet secondaire car on change un élément en déhors de la fonction
            </code>
      </pre>
      <h3>Fonctions d'ordre supérieur</h3>
      <p>
      <ul>
        <li>Une fonction d'ordre supérieur est une fonction qui prend en argument une autre fonction ou/et qui retourne
          une
          fonction.
        </li>
        <li>
          Permet code réutilisable, flexible et permet des abstactrions puissantes.
        </li>
      </ul>
      </p>
      <pre style="tab-size: 2;">
        <code>
// Je déclare ma fonction d'ordre supérieur customFilter avec les paramètres "arr" (un tableau) et "callback" (une fonction)
function customFilter(arr, callback) {
// Je crée un tableau vide dans lequel je stockerai les éléments filtrés
  const filteredArray = []
// Je parcours chaque élément de l'array "arr" en utilisant une boucle for
  for (let i = 0; i < arr.length; i++) {
// Je vérifie si l'élément actuel de l'array "arr" satisfait la condition définie par le callback
    if (callback(arr[i])) {
// Si la condition est vraie, j'ajoute cet élément au tableau filtré
      filteredArray.push(arr[i])
    }
  }
// Je retourne le tableau filtré une fois la boucle terminée
  return filteredArray
}

// J'initialise un tableau "salaries" contenant différents salaires
const salaries = [1200, 5000, 4000, 2500, 3450, 1800]

// J'affiche le résultat de l'appel à la fonction customFilter avec "salaries" comme tableau et une fonction de callback
// qui vérifie si chaque élément (salaire) est supérieur à 3000
console.log(customFilter(salaries, salary => salary > 3000));
        </code>
      </pre>
      <h3>Expression de fonction</h3>
      <h3>Paramètres par défaut</h3>
      <p>
        Définit une valeur par défaut si un argument correspondant au paramètre en question n'est pas fourni.
      </p>
      <pre style="tab-size: 2;">
        <code>
function welcoming(userName = "visiteur"){
  return `Bienvenue, ${userName}.`
}
console.log(welcoming("Paul"));
console.log(welcoming("Sara"));
console.log(welcoming());
// Ici le paramètre par défaut "visiteur" apparait si aucun UserName n'est définit.
        </code>
      </pre>
      <h3>Fonctions déjà existantes</h3>
      <h3>Recursivité</h3>
    </section>
    <br>
    <section id="logique">
      <h1>4 - La logique</h1>
      <h2>If/else</h2>
      <h2>Switch</h2>
      <h2>Or/and</h2>
      <h2>Not/bang operator</h2>
      <h2>Conditions ternaires</h2>
    </section>
    <br>
    <section id="boucles">
      <h1>5 - Les boucles</h1>
      <h2>While</h2>
      <h2>Do...while</h2>
      <h2>Boucle for</h2>
      <h2>Autres boucles</h2>
      <h2>Break</h2>
      <h2>Les exceptions</h2>
    </section>
    <br>
    <section id="mémoire">
      <h1>Emplacements de mémoire</h1>
      <h2>Heap</h2>
      <p>Espace de mémoire principal ou les objets, tableau et structures JS sont stockés</p>
      <h2>Stack</h2>
      <p>Stocke les variables locales et les références de fonction</p>
      <h2>Contexte d'éxecution</h2>
      <p>Global : quand le script se fait analyser / toutes les déclations de fonctions et de variables y sont hissées
      </p>
    </section>
    <br>
    <section id="tableaux">
      <h1>Les tableaux</h1>
      <h2>Tableau simple</h2>
      <p>...</p>
      <h2>Tableau à plusieurs dimensions</h2>
      <p>...</p>
      <h2>Tableau associatif</h2>
      <p>...</p>
      <h2>Accèder à un élément index/length</h2>
      <p>...</p>
      <h2>Accèder à un élément push/unshift</h2>
      <p>...</p>
      <h2>Retirer un élément pop/shift</h2>
      <p>...</p>
      <h2>Retrouver un élement grâce à sa valeur</h2>
      <p>...</p>
      <h2>Concaténer pour afficher(join)</h2>
      <h2>Splice : ajouter/remplacer/supprimer</h2>
      <h2>Les boulces (for...in)</h2>
      <h2>Les boucle (for...of)</h2>
      <h2>Méthode .forEeach</h2>
      <ul>
        <li>
          Cette méthode prend en argument une fonction de rappel (callback) qui sera exécutée pour chaque élément du
          tableau.
        </li>
        <li>
          Le callback peut recevoir jusqu'à trois arguments : l'élément actuel, l'index de l'élément et le tableau sur
          lequel forEach() a été appelé.
        </li>
        <li>
          Itère sur l'objet original contrairement à .map qui créer un nouvel objet.
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const number = [1,2,3,4]
numbers.forEach((num, index, array) => console.log(num))
// affiche
//1 0(4)[1,2,3,4]
//2 1(4)[1,2,3,4]
//3 2(4)[1,2,3,4]
//4 3(4)[1,2,3,4]
        </code>
      </pre>
      <h2>Méthode .map </h2>
      <ul>
        <li>
          Permet d'itérer sur chaque élément d'un tableau et de créer un nouveau tableau à partir des résultats de
          l'application d'une fonction sur chaque élément.
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
      const people = [
      {
      name: "Pedro",
      age: 25
      },
      {
      name: "Sara",
      age: 26
      },
      {
      name: "Maria",
      age: 27
      }
      ]

      const names = people.map(people => people.name)
      console.log(names)
      //Affiche un nouvel array avec les clé "name"
      //Array(3)
      //0:"Pedro"
      //1:"Sara"
      //2:"Maria"
      //length:3
        </code>
      </pre>
      <h2>Méthode filter </h2>
      <ul>
        <li>
          Crée un nouveau tableau contenant uniquement les éléments qui passent un test spécifié par une fonction de
          rappel.
        </li>
        <li>
          En d'autres termes, elle crée un nouveau tableau en filtrant les éléments du tableau d'origine selon un
          critère défini par la fonction de rappel.
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const heights = [170,185,198,162,187,155,178,207,201,189]

const lessThan180 = heights.filter(height => height < 180)
console.log(lessThan180) // affiche [170, 162, 155, 178]
        </code>
      </pre>
      <h2>Méthode reduce </h2>
      <ul>
        <li>
          La méthode reduce() applique une fonction qui est un « accumulateur ».
        </li>
        <li>
          Elle traite chaque valeur d'une liste (de la gauche vers la droite) afin de la réduire à une seule valeur.
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const marks = [18,5,17,12,20,16,14]

const average = marks.reduce((acc, mark) => acc + mark, 0) / mark.length
// Initialise à 0, puis itère 0+18, 18+5, 23+17, 40+12, ect...
// Divise la somme par le nombre d'éléments pour obtenir une moyenne
console.log(average)
        </code>
      </pre>

      <h2>Concaténer un tableau associatif</h2>
    </section>
    <br>
    <section id="objets">
      <h1>Objets JS</h1>
      <h2>Créer un objet</h2>
      <p>...</p>
      <h2>Le destructuring / affectation par décomposition </h2>
      <p>consiste à créer des variables à partir des propriétés d'un objet ou des éléments d'un tableau.</p>
      <pre style="tab-size: 2;">
        <code>
const userObj = {
  userName: "Karl",
  age: 44,
  country: "Germany"
}

const {age, country, userName} = userObj
console.log(age, country, userName);
// Ici les propriétés de l'objet userObj (userName, age, country) sont extraites et transformées en variables.

const {userName: mainName, age: exactAge, country:origin} = userObj
console.log(MainName, exactAge, Origin)
//Ici les noms de variables ont été changés

const {country, sport = "football", beverage ="beer"} = userObj
console.log(country, sport, beverage)
//Créer des valeurs par défaut si la propriété n'est pas présente dans l'objet d'origine
        </code>
      </pre>
      <p>
        On peut passer des propriété d'objets directement en tant que paramètre à nos fonctions
      </p>
      <pre style="tab-size: 2;">
        <code>
const numbers = {
  num1: 50,
  num2: 100
}
    function foo(numbers) {
      console.log(numbers)
      return numbers.num1 + numbers.num2
}
console.log(foo(numbers))


function foo2({num1, num2}) {
  console.log(numbers)
  return num1 + num2
}
console.log(foo2(numbers))

// Ces 2 fonctions font la même chose. Les propiétés de l'objet on été directement passées en tant de paramètre à la fonction foo2.

const animals = ["cat","dog","mouse","lion"];
const [cat, dog] = animals
console.log(cat, dog)
// Les valeurs du "cat" et "dog" du tableau "animal" ont été textraites dans de nouvelles variables par destructruring.
        </code>
      </pre>
      <p>
        On peut faire ignorer des valeurs lors du destructuring grâce à ",,"
      </p>
      <pre style="tab-size: 2;">
        <code>
const fruits = ["strawberry", "grapes", "banana", "apples"]
const [strawberry, grapes,, apple] = fruits
console.log(strawberry, grapes, apple)
// absence de "banana" ici
        </code>
      </pre>
      <p>
        Exemple avec le reste d'un tableau
      </p>
      <pre style="tab-size: 2;">
        <code>
            EXEMPLE
        </code>
      </pre>
      <h2>Objet Set</h2>
      <h2>Objet Map</h2>
      <h2>Objet WeakSet</h2>
      <h2>Objet WeakMap</h2>
      <h2>REST parameter / nombre infini d'arguments</h2>
      <p>
        Le rest parameter "..." permet de prendre en compte un nombre de strings arbitaire lors de l'appel de la
        fonction concatenation
      </p>
      <pre style="tab-size: 2;">
        <code>
function concatenation(...strings){
  console.log(strings);
  return strings.reduce((acc,cur) => acc + cur)
}

console.log(concatenation("Je ", "suis ", "heureux."));
//  Chacune des 3 strings est ici passée en argument lors de l'appel de la fonction "concatenation"
        </code>
      </pre>
      <h2>Spread operator / syntaxe de décomposition</h2>
      <p>Permet de copier les valeurs d'un élément itérable (tableau, chaîne, objet...).
        pratique pour effecteur une copie superficielle / afficher une liste. Les objets sont des valeurs de référence,
        pas des primitives. Copie d'un objet = copie d'un emplacement de mémoire de celui-ci (shallow copie)
      </p>
      <pre style="tab-size: 2;">
        <code>
const array = [1,2,3,]
console.log(...array)
// Affiche tous les éléments de array

const shallowArrayCopy = [...array, 4,56]
console.log(shallowArrayCopy)
// Affiche 1,2,3,4,5,6 (les numbers sont des primitives donc sont copiés en tant que tel )

const array = [1,2,3,{a:5}]
const shallowArrayCopy = [...array, 4, 5, 6]
array[3].a = 555
// On change la valeur de l'objet {a:5} qui ezt ici copié en tant que valeur de référence.
// Les objets sont des valeurs de référence et non pas des primitives.

const obj = {
  name: Eric,
  age: 52
}

const shallowObjectCopy = {...obj, work: "Magneto"}
// Fonctionne également avec les objets.
        </code>
      </pre>

    </section>
    <br>
    <section id="BOM">
      <h1>BOM (Brower Oriented Model)</h1>
      <h2>Définition</h2>
      <h2>Window</h2>
      <h2>Navigator</h2>
      <h2>History</h2>
      <h2>Location</h2>
      <h2>Screen</h2>
      <h2>Document</h2>
    </section>
    <br>
    <section id="DOM">
      <h1>DOM (Document Oriented Model)</h1>
      <h2>Accéder aux élément du DOM</h2>
      <h3>getElementsByTagName() </h3>
      <ul>
        <li>
          Sélectionne tous les éléments avec la balise entre parenthèses
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const paragraphs = document.getElementsByTagName('p');
        </code>
      </pre>
      <h3>getElementById()</h3>
      <ul>
        <li>
          Sélectionne tous les éléments avec la balise entre parenthèses
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const paragraphe2 = document.getElementById('paragraphe2');
        </code>
      </pre>
      <h3>getElementsByClassName()</h3>
      <ul>
        <li>
          Sélectionne tous les éléments avec la classe entre parenthèses
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const paragraphe = document.getElementById('paragraphe');
        </code>
      </pre>
      <h3>querySelector()</h3>
      <ul>
        <li>
          Sélectionne un seul élément : celui avec le sélecteur entre parenthèses
        </li>
      </ul>
      <pre>
        <code>
const premierParagraphe = document.querySelector('p');
        </code>
      </pre>
      <h3>querySelectorAll()</h3>
      <ul>
        <li>
          Sélectionne tous les éléments avec le sélecteur entre parenthèses
        </li>
      </ul>
      <pre style="tab-size: 2;">
        <code>
const paragraphs = document.querySelectorAll('p');
        </code>
      </pre>

      <h2>Modifier des éléments</h2>
      <p>textContent : Modifie le texte d'un élément
      </p>
      <p>InnerHTML : Modifie l'HTML d'un élément</p>
      <h2>Ajouter des éléments</h2>
      <p>
      <ul>
        <li>createElement() - Crée un élément</li>
        <li>prepend() - Ajoute l'élément entre parenthèses devant l'élément cible</li>
        <li>append() - Ajouter l'élément entre parenthèses derrière l'élément cible (peut contenir du texte)</li>
        <li>appendChild() - Ajouter l'élément entre parenthèses derrière l'élément cible (ne peut pas contenir du texte)
        </li>
        <li>insertBefore() - Insère un élément avant l'élément cible</li>
      </ul>
      </p>
      <h2>Supprimer des éléments</h2>
      <h2>Modifier style des éléments</h2>
    </section>
    <br>
    <section id="évènements">
      <h1>Evènements</h1>
      <h2>Définition</h2>
      <h2>Les écouteurs</h2>
      <h2>Propagation</h2>
      <h2>Planifier un script</h2>
      <p>setTimeout</p>
      <p>setInterval</p>
    </section>
    <br>
    <section id="POO">
      <h1>POO</h1>
      <h2>Définition</h2>
      <h2>Objet littéral</h2>
      <h2>Constructeur</h2>
      <h2>Prototypes</h2>
      <h2>Créer objet</h2>
      <h2>Héritage</h2>
      <h2>Bind, Call et Apply</h2>
      <h2>Créer objet avec constructeur</h2>
      <h2>Getter et Setter</h2>
    </section>
    <br>
    <section id="date">
      <h1>Date</h1>
      <h2>Objet Date</h2>
      <h2>Getter/setter avec Date</h2>
      <h2>Transformer date</h2>
    </section>
    <br>
    <section id="api">
      <h1>API</h1>
      <h2>Définition</h2>
      <h2>AJAX</h2>
      <h2>XMLHttpRequest</h2>
      <p>get</p>
      <p>send</p>
    </section>
    <br>
    <section id="asynchrone">
      <h1>Asynchrone</h1>
      <h2>Définition</h2>
      <h2>Promesses</h2>
      <p>Objet représentant l'achèvement ou l'échec éventuel d'une opération asynchrone.
        3 était : en attente (pending), résolue (fulfilled) ou rejetée (rejected).
        Une promesse est créée avec le constructeur Promise, et elle expose une méthode then pour réagir lorsque la
        promesse est résolue,
        et une méthode catch pour gérer les erreurs lorsqu'elle est rejetée.
      </p>
      <h2>Async et Await</h2>
      <h2>Callback</h2>
      <p>fonction qui est passée comme argument à une autre fonction et qui est ensuite invoquée à un moment ultérieur
        dans l'exécution de cette fonction parente, généralement en réponse à un événement ou à une condition
        spécifique.
      </p>
      <h2>Fetch & axios</h2>
      <p>Get / avec fetch</p>
      <p>Get / send avec Axios</p>
      <p>bibliothèque JavaScript qui simplifie l'envoi de requêtes HTTP à partir du navigateur ou de Node.js. Elle
        utilise les Promesses pour gérer les requêtes asynchrones
        et facilite la communication avec des serveurs web via les protocoles HTTP et HTTPS. Axios est largement
        utilisée dans le développement web moderne pour effectuer des
        requêtes AJAX de manière simple et efficace, en offrant une interface fluide pour envoyer et recevoir des
        données depuis et vers des serveurs web.</p>
    </section>
    <br>
    <section id="cookies">
      <h1>Cookies</h1>
      <h2>LocalStorage / SessionStorage</h2>
    </section>
    <br>
    <section id="inclassables">
      <h1>Inclassables</h1>
      <h2>Géolocalisation</h2>
      <h2>Modules</h2>
      <p>Import</p>
      <p>Export</p>
      <p>Mode strict</p>
    </section>
    <br>

  </main>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>
    hljs.highlightAll();
  </script>
  <script src="javascript.js"></script>
</body>

</html>
